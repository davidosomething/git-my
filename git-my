#!/usr/bin/env bash

# git-my v0.4.0
#
# Lists a user's remote branches and shows if it was merged
# and/or available locally
#
# Copyright (c) 2015 David O'Trakoun <me@davidosomething.com>
#
# Usage:
#   git my
#

set -eu

# _check_in_repository
#
# Exits with error if not a git repository
#
_check_in_repository() {
  git rev-parse --git-dir >/dev/null 2>&1
}

# _get_local_branches
#
# Proper way to get a porcelain list of local branches for shell script use
#
_get_local_branches() {
  local fmt
  local cmd_get_local_branches

  # shellcheck disable=SC2016
  fmt='
    r=%(refname)
    refname_without_prefix=${r#refs/heads/}
    printf "%s\t%s\n" "$refname_without_prefix"
  '

  cmd_get_local_branches=$(
    git for-each-ref --shell --format="$fmt" refs/heads
  )

  eval "$cmd_get_local_branches"
}

# _get_everyones_remotes
#
# Get porcelain list of all remote branches
#
# @TODO support remote_name (currently origin)
#
_get_everyones_remotes() {
  local fmt
  local cmd_everyones_remotes

  local remote_name
  remote_name=${1:-"origin"}

  # user.name<TAB>branch.name
  # the TAB is used as a delimiter to awk with
  # shellcheck disable=SC2016
  fmt='
    a=%(authorname)
    r=%(refname)
    refname_without_prefix=${r#refs/remotes/$remote_name/}
    printf "%s\t%s\n" "$a" "$refname_without_prefix"
  '

  cmd_everyones_remotes=$(
    git for-each-ref --shell --format="$fmt" "refs/remotes/$remote_name"
  )

  eval "$cmd_everyones_remotes"
}

# _get_merged_remote_branches
#
# @param string optional remote to list merged branches of. Defaults to
#        "origin/master"
# @output names of remote branches that are merged into given branch
_get_merged_remote_branches() {
  local remote
  local remote_name
  #local remote_refname
  local merged_remote_branches
  local stripped_branchnames

  remote=${1:-"origin/master"}
  # trim from end of string until / for the remote name
  remote_name=${remote%/*}
  # trim from beginning of string until / for the remote refname
  #remote_refname=${remote#*/}

  merged_remote_branches=$( \
    git branch --no-color \
      --remotes \
      --merged "$remote" \
    )

  # remove "origin/"
  # shellcheck disable=SC2001
  stripped_branchnames=$( \
    echo "$merged_remote_branches" | sed "s/^\s*$remote_name\///g" \
    )

  echo "$stripped_branchnames"
}

# _filter_mine
#
# @param git_user
# @param branchnames
# @output branchnames owned by current git user
_filter_mine() {
  local git_user
  local branchnames
  git_user=$1
  branchnames=$2

  # use eval to not parse the fmt string
  local my_remotes
  my_remotes=$(echo "$branchnames" | grep -i "^$git_user")

  # output only the branchname
  echo "$my_remotes" | grep -v "HEAD" | awk -F'\t' '{ print $2 }'
}

_merge_lists() {
  # shellcheck disable=SC2086
  echo $1 $2 | tr ' ' '\n' | sort -u
}

# _decorate_merged
#
# @param string my_branches list of remote branch names owned by me
# @param string local_branches list of local branch names
# @param string merged_remote_branches list of all remote branch names merged
#        into another branch
# @output table of branch names and status
_decorate_merged() {
  local my_branches=$1
  local local_branches=$2
  local merged_remote_branches=$3
  local zebra=0
  local is_first=''

  # heading
  echo '  local | remote | tracked | branch'

  # body
  for branchname in $my_branches
  do
    local decorated=''
    local is_local=' '
    local is_tracked=' '
    local is_merged=' '

    echo "$local_branches" | grep -q "$branchname" && \
      is_local='✓'

    if git rev-parse --symbolic-full-name "$branchname"@{u} >/dev/null 2>&1; then
      is_tracked='✓'
    fi

    echo "$merged_remote_branches" | grep -q "$branchname" && \
      is_merged='✓'

    decorated=$(printf "%s    %s   |   %s    |    %s    | %s" \
      "$is_first" "$is_local" "$is_merged" "$is_tracked" "$branchname"
    )

    if [ $zebra = 0 ]; then
      echo -en "\e[48;5;0m${decorated}"
      zebra=1
    else
      echo -en "\e[48;5;236m${decorated}"
      zebra=0
    fi

    is_first='\n'
  done
  echo
}

_main() {
  local decorated
  local everyones_remotes
  #local git_remote
  local git_user
  local local_branches
  local merged_remote_branches
  local my_remotes

  local remote=${1:-"origin/master"}

  # trim from end of string until / for the remote name
  local remote_name=${remote%/*}
  # trim from beginning of string until / for the remote refname
  local remote_ref=${remote#*/}

  git_user=$(git config --get user.name)
  #git_remote=$(git config --get "remote.${remote_name}.url")
  everyones_remotes=$(_get_everyones_remotes "$remote_name")
  my_remotes=$(_filter_mine "$git_user" "$everyones_remotes")
  merged_remote_branches=$(_get_merged_remote_branches "$remote_name/$remote_ref")
  local_branches=$(_get_local_branches)
  my_branches=$(_merge_lists "$my_remotes" "$local_branches")

  _decorate_merged "$my_branches" "$my_remotes" "$local_branches" "$merged_remote_branches"
}

if ! _check_in_repository ; then
  echo "This is not a git repository."
  exit 1
fi

_main "$@"

